#' Plot Results from the Pettitt Change‐Point Test
#'
#' @description
#' Creates a two‐panel visualization of the Mann–Whitney–Pettitt test:
#' 1. Upper panel: Pettitt Ut statistic over time with its critical threshold
#'    and highlighted potential change point(s).
#' 2. Lower panel: the original annual maximum series (AMS) with optional
#'    trend line and segment‐wise mean estimates, marking the change point.
#'
#' @param df A data frame containing at least the following columns:
#'   \describe{
#'     \item{\code{year}}{Numeric or integer vector of observation years.}
#'     \item{\code{max}}{Numeric vector of observed annual maxima (AMS).}
#'   }
#'   The function will add:
#'   \itemize{
#'     \item \code{ut}: Pettitt Ut statistic for each year.
#'   }
#' @param results A list of Pettitt test outputs. Generated by \code{\link{pettitt.test}}.
#' @param show_trend Logical; if \code{TRUE} (default), overlays a fitted line through the AMS series.
#'
#' @return A \pkg{patchwork} object consisting of two vertically stacked
#' \pkg{ggplot2} panels:
#' \itemize{
#'   \item The time series of Ut with dashed horizontal line at +/-\code{k.critical}
#'     and points marking the potential change point.
#'   \item The AMS series with optional trend line, segment means drawn as horizontal
#'     segments, and change‐point markers.
#' }
#'
#' @details
#' 1. The Ut statistic is plotted as a solid line against year; the critical value
#'    is shown with a dashed red line.
#' 2. If \code{change.index} > 0, that year’s point is highlighted in blue.
#' 3. The lower panel divides the series into one or two segments (pre‐ and
#'    post‐change) and draws their mean flow levels as green horizontal segments.
#'
#' @seealso
#' \code{\link[ggplot2]{geom_line}},
#' \code{\link[ggplot2]{geom_hline}}, 
#' \code{\link[ggplot2]{geom_segment}}
#'
#' @import ggplot2
#' @import patchwork
#' @export

pettitt.plot <- function(data, years, results, show_trend = TRUE) {

	# Add ut to df and create change point df (if change point is significant)
	df <- data.frame(
		max = data,
		year = years,
		ut = results$ut
	)

	change_df <- df[results$change.index, ]

	# Get the segment endpoints depending on whether there is a change point
	n <- length(results$ut)
	ends <- if (results$change.index == 0) c(1, n) else c(1, results$change.index, n) 

	n_ends <- length(ends)
	get_segment_mean <- function(i) mean(df$max[ends[i]:ends[i + 1]])

	# Compute the segment means for the plot
	segment_df <- data.frame(
		x = df$year[ends[-n_ends]],            
		xend = df$year[ends[-1]],
		y = sapply(1:(n_ends - 1), get_segment_mean)
	)

	# Generate the labels with proper formatting
	ut_label <- expression(U[t] ~ Statistic)
	flow_label <- expression(AMS ~ m^3/s)

	# First subplot: Mann-Whitney-Pettitt Test
	p1 <- ggplot(df, aes(x = .data$year, y = .data$ut)) +
		geom_line(aes(color = "black"), linewidth = 1.2) +
		geom_hline(
			aes(yintercept = results$k.critical, color = "red"),
			linewidth = 1.2,
			linetype = "dashed",
		) +
		geom_point(data = change_df, aes(color = "blue"), size = 4) +
		labs(
			title = "Mann-Whitney-Pettitt Test",
			x = "Year",
			y = ut_label,
			color = "Legend") +
		scale_color_manual(
			values = c("black" = "black", "red" = "red", "blue" = "blue"),
			breaks = c("black", "red", "blue"),
			labels = c(ut_label, "Change Point Threshold", "Potential Change Point")
		)
		
	# Also plot the original flow data and segment means
	p2 <- ggplot(df, aes(x = .data$year, y = max)) +
		geom_point(aes(color = "black"), size = 2.25) +
		(if (show_trend) geom_line(color = "black", linewidth = 1.1) else NULL) + 
		geom_segment(
			data = segment_df, 
			aes(x = .data$x, xend = .data$xend, y = .data$y, color = "green4"),
			linewidth = 1.2 
		) + 
		geom_point(data = change_df, aes(color = "blue"), size = 4) +
		labs(x = "Year", y = flow_label, color = "Legend") +
		scale_color_manual(
			values = c("black" = "black", "green4" = "green4", "blue" = "blue"),
			breaks = c("black", "green4", "blue"),
			labels = c(flow_label, "Segment Mean(s)", "Potential Change Point")
		)	

	# Stack plots on top of each other and return
	add_theme(add_scales(p1)) / add_theme(add_scales(p2))

}
